Node.js의 특징을 설명하기 앞서 다음의 3가지 상황에 대해서 생각해 보겠습니다.

1. 스레드라는 청년이 작은 라면 전문점을 개업햇습니다. 자본금도 충분하지 않았고 혼자서도 잘 운영할 수 있을거라고 생각했기 때문에 스레드는 직원을 두지 않기로 했습니다.
가게를 오픈하고 손님들이 찾아왔습니다. 첫 번째 손님이 "파송송 라면"을 주문했습니다. 주문을 받은 스레드는 주방으로 가서 라면을 끓이기 시작했습니다.
스레드가 라면을 끓이고 있는데 두 번재 손님이 찾아왔습니다. 라면은 굉장히 빨리 만들 수 있는 음식이지만 끓이는 동안 계속 신경을 써야 하기 때문에,
라면을 끝까지 조리하기 전까지는 두 번재 손님의 주문을 받지 못했습니다.
두번째 손님은 스레드가 주방에서 라면을 다 끓이고 나올 때까지 주문도 하지 못한 채 기다려야 했습니다.
스레드는 첫 번째 손님이 주문한 라면을 다 준비한 후에야 두 번째 손님의 주문을 받을 수 있었습니다.
그 손님은 주문도 못하고 기다리는 시간이 낭비라고 생각했고, 스레드의 라면 가게에 대한 안 좋은 인상을 갖게 되었습니다.

2. 재벌 2세인 제레미는 전국에서 가장 큰 라면 전문점을 개업했습니다. 동시에 여러 명의 손님이 오더라도 동시에 여러 명의 주문을 받고 라면을 만들어서 제공할 수 있도록 여러명의 직원을 뽑았습니다.
그리고 직원들을 모두 스레드라고 불렀습니다. 가게를 오픈하고 손님들이 물밀듯이 들어왔지만 스레드가 많았기 때문에 문제없이 주문을 받고 맛있는 라면을 제때에 제공했습니다.
장사가 아주 잘 되었지만, 어느 날 경기가 안 좋아졌습니다. 그러면서 가게에 손님들이 조금씩 줄어들었고 스레드가 하는 일 없이 낭비하는 시간이 점점 길어졌습니다.
얼마 지나지 않아 라면을 팔고 생기는 매출보다 직원을 고용하는 데 드는 비용이 더 커졌고 제레미의 라면 가게는 적자에 시달리게 되었습니다.

3. 스레드는 라면 전문점을 혼자 운영하면서 생기는 비효율적인 문제를 개선할 좋은 방법이 없을까 고민합니다. 그리고 논블로킹이라는 라면을 만들어주는 기계를 구입하게 됩니다.
이제 스레드는 라면을 만들어주는 기계인 논블로킹이 있기 때문에 여러 손님이 동시에 오더라도 주문을 받아 논블로킹에 라면을 만들라는 지시만 하고 다른 일을 할 수 있게 되었습니다.
논블로킹이 라면을 만드는 동안 스레드는 다른 손님의 주문을 받을 수 도 있고, 라면이 다 만들어지면 라면 기계가 보내는 신호를 받아 만들어진 라면을 손님 테이블로 바로 가져다줄 수 있게 되었습니다.
이제 더 이상 손님은 라면을 주문하기 위해서 대기할 필요가 없고, 스레드 역시 라면이 만들어지는 동안 가만히 기다릴 필요가 없어졌습니다.
최소한의 비용을 들여 논블로킹 기계 하나를 장만함으로써 최대의 효율을 가질 수 있게 된 것입니다.

Node.js의 특징을 설명하기 위해 3가지 상황을 살펴보았습니다. 돈이 많고 가지고 있는 자원이 많다면 성능 면에서는 두 번째 상황에 해당하는 작업 방식이 가장 좋을 것입니다.
하지만 가지고 있는 자원이 한정적이라면 적은 자원을 가장 효율적으로 사용할 수 있는 작업 방식은 분명 세 번째 상황일 것입니다.

프로그래밍 언어마다 조금씩 차이가 있지만 3가지 방식중 한 가지 형태로 실행됩니다.
대다수의 초기 프로그래밍 언어들이 첫 번째 상황에 해당됩니다.
그리고 두 번째 상황에 해당하는 대표적인 언어가 자바이고, Node.js는 세 번째 상황에 해당합니다.
즉, Node.js는 적은 자우너으로도 최대한의 효율을 올릴 수 있다는 특징을 가지고 있습니다.
Node.js는 가볍고, 빠르고, 좋은 성능을 제공합니다.

자, 그럼 본격적으로 Node.js의 특징을 살펴보겠습니다. Node.js는 논블로킹 I/O와 싱글 스레드, 이벤트 루프를 통한 높은 처리 성능을 가지고 있습니다.
논블로킹 I/O와 싱글 스레드, 이벤트 루프가 도대체 무엇이길래 높은 성능을 가지고 있다고 하는 걸까요?

논블로킹 I/O
프로그래밍 언어별로 여러 개의 작업을 동시에 처리할 수 있는 언어가 있고, 한 번에 하나의 작업만 처리할 수 있는 언어가 있습니다.
기본적으로 JS는 한 번에 하나의 작업을 처리하는 후자에 속합니다. 하지만 I/O작업의 경우는 JS도 동시에 처리할 수 있습니다.
여기서 I/O는 입력과 출력을 의미하는데, 파일 읽기/쓰기와 같은 파일 시스템 처리와 데이터베이스로 데이터를 전송/조회하는 일과 같은 네트워크를 통한 요청이 이에 속합니다.
이런 작업을 할 때 Node.js는 논블로킹 방법을 사용할 수 있습니다.

먼저 블로킹과 논블로킹에 대해서 알아보겠습니다.

블로킹은 함수를 호출하면 호출된 함수가 작업을 마칠 때까지 제어권을 돌려주지 않고 함수가 종료될 때까지 대기하는 방식을 말합니다.
반대로 논블로킹은 함수를 호출하면 호출된 함수에게 바로 제어권을 넘겨줘서 다른 작업을 바로 진행할 수 있도록 하는 방식입니다.

즉, 블로킹은 함수를 호출하고 나면 함수가 완전히 종료가 될 때까지 다른 작업을 진행하지 못하고 기다려야 하는 것이고,
논블로킹은 함수를 호출한 후 호출된 함수가 실행되는 중에도 다른 작업을 동시에 진행할 수 있다는 것을 의미합니다.
필자가 앞서 라면 가게의 예를 들면서 라면을 만들어주는 기계에 논블로킹이라는 이름을 붙인 것이 바로 이 이유 때문입니다.

논블로킹 I/O는 Node.js가 가지고 있는 하나의 특징입니다. 논블로킹이라고 해서 꼭 좋은 것이고 블로킹이라고 해서 꼭 나쁜 것은 아닙니다.
어떤 경우에는 반드시 블로킹을 통해서 사전 작업이 잘 종료되기를 기다렸다가 후속 작업을 해야할 때도 있습니다.
논블로킹으로 프로그램을 구현할 때에는 논블로킹으로 호출한 함수가 정상적으로 종료되지 않았을 때를 반드시 고려해야 합니다.

블로킹과 논블로킹은 동기식, 비동기식으로도 불리기에, 두 용어에 대해서도 익숙해질 필요가 있습니다.

블로킹 I/O로 파일 쓰기할 때의 프로세스
1. 함수를 호출해서 파일 쓰기를 요청합니다
2. 파일 쓰기를 실행합니다.
3. 파일 쓰기가 완료될 때까지 다음 코드를 실행하지 않고 대기하게 됩니다.
4. 파일 쓰기가 완료되면 다음 코드를 실행합니다.

논블로킹 I/O로 파일 쓰기할 때의 프로세스
1. 함수를 호출해서 파일 쓰기를 요청합니다.
2. 바로 다음 코드를 실행합니다.
3. 파일 쓰기가 실행됩니다.
4. 파일 쓰기가 완료되면 콜백 함수를 호출해서 파일 쓰기가 완료되었음을 알려줍니다.
5. 파일 쓰기 완료 후 실행해야 할 프로그램을 실행합니다.

싱글 스레드
Node.js는 싱글 스레드를 사용합니다. 여기서 싱글 스레드라는 것은 스레드 하나를 사용한다는 의미입니다.
그렇다면 스레드를 하나만 사용한다는 것은 무슨 의미일까요?
스레드가 하나라는 말은 곧, 동시에 하나의 작업만을 처리할 수 있다는 뜻입니다.
기본적으로 JS같은 싱글 스레드 방식의 언어는 작성된 프로그램을 순차적으로 실행하고, 여러 작업을 동시에 처리할 수 없도록 되어 있습니다.

앞서 설명했던 3가지 상황중, 두 번째 상황에서 직원을 많이 고용하고 그 직원들을 모두 스레드라고 불렀습니다.
직원들은 각자 자신일 처리해야 할 일만 하면 되기 때문에 동시에 여러 작업을 진행할 수 있는 프로그래밍 방식을 멀티 스레드라고 합니다.
Node.js는 싱글 스레드 방식, 즉 하나의 스레드만을 이용해서 작업을 처리합니다.

스레드에 대해서 조금 더 구체적으로 설명하기 위해서 컴퓨터의 작업 처리 방법을 먼저 알아보겠습니다.
컴퓨터는 작업을 처리하기 위해서 프로세스라는 작업 단위를 두고 프로세스를 통해서 작업을 처리합니다.
컴퓨터에서 작동하는 Node.js를 포함한 여러 가지 프로그램은 개별적인 프로세스로 리소스를 할당받고 실행됩니다.
스레드는 프로세스 안에서 작업을 처리하기 위해 실행되는 흐름의 단위인데, 하나의 프로세스는 여러 개의 스레드를 생성해서 여러 작업을 동시에 처리할 수 있습니다.

JAVA는 멀티 스레드를 사용하고, Node.js는 싱글 스레드를 사용합니다.
Node.js를 실행하면 컴퓨터는 프로세스를 생성하고 프로세스 안에서는 여러 개의 스레드가 생성되지만,
우리가 프로그램을 통해 직접 제어할 수 있는 스레드는 하나밖에 없기 때문에 Node.js를 싱글 스레드 방식이라고 얘기하는 것입니다.

멀티 스레드를 사용하면 동시에 어려 개의 작업을 처리할 수 있으니까 훨씬 좋은 것이 아닌가하는 의구심이 들 것입니다.
하지만 처리하려는 작업이 무엇인지에 따라서 멀티 스레드가 유리할 수도 있고, 아닐 수도 있습니다.

멀티 스레드 방식을 사용하면 동시에 여러 작업을 실행할 수 있어서 성능면에서는 좋을지 모르지만 굉장히 많은 자원을 필요로 하게 되고,
때로는 자원이 재대로 사용되지 않는 비효율이 생길 수도 있습니다.
Node.js는 싱글 스레드를 사용하지만, 싱글 스레드의 약점을 극복하기 위해서 논블로킹을 사용하여 파일 쓰기, 네트워크를 통한 데이터베이스 처리 등의 작업을 하는동안
컴퓨터가 쉬지않고 다른 작업을 바로 실행시킬 수 있게 합니다. 이로인해 적은 자원으로도 큰 효율을 낼 수 있도록 구성된 것입니다.

정리하자면 Node.js는 JS를 실행하는 부분에 대해서만 싱글 스레드로 구성되고, 논블로킹 I/O와 이벤트 루프를 통해서 동시에 여러 작업을 할 수 있도록 해줍니다.

이벤트 루프
Node.js는 V8엔진과 libuv, llhttp, c-ares, OpenSSL, zlib이라는 라이브러리로 구성되어 있습니다.
이 중 libuv 라이브러리는 이벤트 루프를 통해서 JS가 가지고 있던 싱글 스레드의 약점을 극복하고 효율적으로 작업을 처리할 수 있도록 해줍니다.

이벤트 루프에 대해 설명하기 위해서 V8 엔진이 어떻게 동작이 되는지 살펴보겠습니다.
JS 엔전은 다음 2개의 주요 컴포넌트로 이루어집니다.

메모리 힙: 메모리 할당이 일어나는 컴포넌트
콜 스택: 코드 실행을 위한 컴포넌트

JS 엔진이 아니라 브라우저 자체에서 제공하는 기능인 DOM, AJAX, Timeout같은 기능을 WEB API라고 부릅니다.

JS는 싱글 스레드 언어이고, 이것은 하나의 콜 스택을 가지고 있다는 것을 의미합니다. 그래서 한 번에 하나의 작업만을 처리할 수 있습니다.
JS는 처리해야 할 작업을 콜 스택에 쌓고 하나씩 처리합니다.

JS가 콜 스택에서 실행한 비동기 함수는 WEB API를 호출하고, WEB API는 콜백 함수를 콜백 큐에 밀어 넣습니다.

이벤트 루프는 콜 스택과 콜백 큐의 상태를 체크하고, 콜 스택이 빈 상태가 되면 콜백 큐의 첫 번째 콜백을 콜 스택으로 이동시킵니다.
이러한 작업이 반복적으로 일어나고, 이런 반복적인 행동을 틱이라고 합니다.
그래서 JS만 보면 싱글 스레드 언어이고 한 번에 하나의 작업만 실행할 수 있지만,
브라우저 내에서 비동기 함수인 WEB API와 콜백 큐, 이벤트 루프 때문에 멀티 스레드처럼 동시에 다중 작업을 처리하는 효과를 볼 수 있습니다.

다시 Node.js를 살펴보겠습니다. Node.js는 논블로킹 I/O를 지원하기 위해서 libuv라는 라이브러리에 이벤트 루프가 구현되어 있습니다.
Node.js에서 JS엔진은 비동기 처리를 위해서 Node.js의 API를 호출하며, 이때, 넘겨진 콜백은 libuv의 이벤트 루프를 통해서 스케줄링되고 실행됩니다.

앞서 살펴본 바와 같이 Node.js는 논블로킹 I/O와 싱글 스레드, 이벤트 루프를 통한 높은 처리 성능을 가지고 있습니다.
하지만 분명 JAVA와 같은 언어처럼 멀티 스레드가 필요한 서비스를 구축해야 할 필요가 있습니다.
Node.js는 싱글 스레드이지만 Cluster 모듈이나 PM2를 사용해서 멀티 스레드의 효과를 볼 수 있습니다.
정확히는 싱글 스레드인 Node.js가 CPU의 코어를 추가적으로 사용해서 작업을 병렬적으로 처리하는 것이 가능합니다.
즉, CPU 코어 하나당 프로세스 하나가 실행이 되는 것을 클러스터링이라고 합니다.
이렇게 되면 요청을 분산시키고 병렬로 처리할 수 있기 때문에 멀티 스레드 언어와 동일한 효과를 볼 수 있습니다.